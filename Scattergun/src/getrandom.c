/**
 * @file
 * Get Random<BR>
 * Copyright 2020 Digital Aggregates Corporation, Colorado, USA.<BR>
 * "Digital Aggregates Corporation" is a registered trademark.<BR>
 * Licensed under the terms of the Scattergun license.<BR>
 * author:Chip Overclock<BR>
 * mailto:coverclock@diag.com<BR>
 * http://www.diag.com/nagivation/downloads/Scattergun.html<BR>
 * http://github.com/coverclock/com-diag-scattergun<BR>
 *
 * USAGE
 *
 * getrandom [ -d ] [ -v ] [ -r ] [ -n ]
 *
 * EXAMPLES
 *
 * getrandom -r | dd of=random.dat bs=4096 count=1024 iflag=fullblock
 * 
 * ABSTRACT
 *
 * Continuously output thirty-bit binary numbers generated by the Linux
 * getrandom(2) system call.
 */

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <errno.h>
#include <sys/random.h>

static ssize_t mygetrandom(void * pp, size_t ss, unsigned int flags)
{
    ssize_t rc = sizeof(uint8_t);
    uint8_t * bb = (uint8_t *)pp;
    static int state = 0;
    if (ss == 0) {
        rc = -1;
    } else {
        switch (state) {
        case 0:
            *bb = 0x11;
            state = (state + 1) % 4;
            break;
        case 1:
            *bb = 0x22;
            state = (state + 1) % 4;
            break;
        case 2:
            *bb = 0x33;
            state = (state + 1) % 4;
            break;
        case 3:
            *bb = 0x44;
            state = (state + 1) % 4;
            break;
        default:
            rc = 0;
            break;
        }
    }
    return rc;
}

int main(int argc, char * argv[])
{
    ssize_t length = -1;
    uint32_t value = 0;
    uint8_t * here = (uint8_t *)0;
    size_t size = 0;
    ssize_t (*fp)(void *, size_t, unsigned int) = &getrandom;
    unsigned int flags = 0;
    int verbose = 0;
    int ndx = 0;
    const char * name = (const char *)0;
    name = ((name = strrchr(argv[0], '/')) == (char *)0) ? argv[0] : name + 1;
    for (ndx = 1; ndx < argc; ++ndx) {
        if (strncmp(argv[ndx], "-d", sizeof("-d")) == 0) {
            fp = &mygetrandom;
        } else if (strncmp(argv[ndx], "-n", sizeof("-n")) == 0) {
            flags |= GRND_NONBLOCK;
        } else if (strncmp(argv[ndx], "-r", sizeof("-r")) == 0) {
            flags |= GRND_RANDOM;
        } else if (strncmp(argv[ndx], "-v", sizeof("-v")) == 0) {
            verbose = !0;
        } else {
            errno = EINVAL;
            perror(argv[ndx]);
        }
    }
    while (!0) {
        value = 0;
        here = (uint8_t *)&value;
        size = sizeof(value);
        while (size > 0) {
            length = (*fp)(here, size, flags);
            if (verbose) fprintf(stderr, "%s: [%zd]\n", name, length);
            if (length < 0) {
                perror("getrandom");
                return 1;
            } else if (length == 0) {
                return 0;
            } else if (length > size) {
                errno = EINVAL;
                perror("getrandom");
                return 1;
            } else {
                /* Do nothing. */
            }
            here += length;
            size -= length;
        }
        if (fwrite(&value, sizeof(value), 1, stdout) == 1) {
            /* Do nothing. */
        } else if (ferror(stdout)) {
            perror("fwrite");
            return 1;
        } else {
            return 0;
        }
    }
}
